<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>树莓派</title>
    <url>/2019/11/10/%E6%A0%91%E8%8E%93%E6%B4%BE/</url>
    <content><![CDATA[<a id="more"></a>

<p>树莓派终于在前天回到了，又折腾了两天才把系统装好</p>
<p>现在记录以下官方系统如何安装中文字体</p>
<ol>
<li>安装中文字体包：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ttf-wqy-zenhei</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装中文输入法：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install scim-pinyin</span><br></pre></td></tr></table></figure>

<p>然后输入<kbd>scim</kbd>激活中文输入法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scim</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装完后输入</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure>

<p>选择<kbd>Localisation Options</kbd></p>
<p>回车，选择<kbd>changs locals</kbd></p>
<p>然后在出现的列表中下翻，选择<kbd>zh_cn.utf-8</kbd>,按空格键确认选择，回车键确认安装</p>
<p>下一个页面也选择<kbd>zh_cn.utf-8</kbd></p>
<p>这就ok了。原谅我全程没放一张图，因为最近作业真的太多了(<del>试图掩盖偷懒的事实</del>)，有机会一定补上~</p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>English-notes1</title>
    <url>/2019/11/05/English-notes1/</url>
    <content><![CDATA[<ol>
<li>You are not getting a damn thing from your lot.It will stay there for years.At least he will pay your interest.</li>
<li>I like a buy a house.</li>
<li>What do you do with such determination and hope.</li>
<li>Summer passed into fall,and winds blew cold.</li>
<li>He seemed to stand a little straighter.He was heavier.He had a look of confidence.</li>
<li>He found a small,abandoned piece of property with a house and shed.</li>
<li>He grew in stature in my mind.In the end,I think he stood as tall,and as proud,as the greatest American industrialists.</li>
<li>They had all reached their success by the same route and by the same values snd principles:vision,determination,self-control,optimism,self-respect and,above all,integrity.</li>
</ol>
<a id="more"></a>









]]></content>
      <categories>
        <category>English-notes</category>
      </categories>
      <tags>
        <tag>English</tag>
        <tag>notes</tag>
        <tag>Englisg-notes</tag>
      </tags>
  </entry>
  <entry>
    <title>九万字</title>
    <url>/2019/11/03/%E4%B9%9D%E4%B8%87%E5%AD%97/</url>
    <content><![CDATA[<p>有些歌曲，我喜欢把它称作回忆。</p>
<a id="more"></a>

<h3 id="九万字"><a href="#九万字" class="headerlink" title="九万字"></a>九万字</h3><p>漂泊的雪，摇曳回风<br>诗意灵魂，更迭情人<br>总贯用轻浮的茂盛，掩抹深沉<br>有谁不是 少年热枕<br>孑然一身 爱一个人<br>望尽了毕生温柔眼神</p>
<p>写得出最刻薄的字文<br>以讥笑这庸尘<br>却不忍 斥你毫分<br>我也算万种风情 实非良人<br>谁能有幸 错付终身<br>最先动情的人 剥去利刃<br>沦为人臣<br>我爱你苍凉双眼 明月星辰<br>不远万里 叩入心门<br>一个孤僻的唇    摘获了你首肯<br>有谁不是 死而寻生<br>险些终结 险些长命<br>睡梦中无数次的自刎<br>笔下有最淋漓的爱恨<br>以剜挑这浮生<br>只写你衣不染尘<br>我也算万种风情 实非良人<br>谁能有幸 错付终身<br>幻想岁月无声<br>百年之后 合于一坟<br>我爱你苍凉双眼 留有余温<br>荒芜的心 旷野徒奔<br>你会弹落烟尘 抹去指上灰痕<br>各自纷呈<br>看那些流离失所的人<br>莫衷一是 层层围困<br>从来酿酒的人 分外清醒<br>独善其身<br>常言说 命运半点不由人<br>不信常言偏信方寸<br>那些荒唐传闻<br>化名称为青春<br>红尘滚滚</p>
]]></content>
      <categories>
        <category>回忆</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS初体验—-yum</title>
    <url>/2019/11/02/CentOS%E5%88%9D%E4%BD%93%E9%AA%8C%E2%80%94-yum/</url>
    <content><![CDATA[<h3 id="yum是什么"><a href="#yum是什么" class="headerlink" title="yum是什么"></a>yum是什么</h3><blockquote>
<p>Yum（全称为 Yellow dog Updater, Modified）是一个软件包管理器，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</p>
</blockquote>
<a id="more"></a>

<h3 id="常用的yum命令"><a href="#常用的yum命令" class="headerlink" title="常用的yum命令"></a>常用的yum命令</h3><ol>
<li>显示已经安装的软件包</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list installed</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查找可以安装的软件包（以ftp为例）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list ftp</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装软件包</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install ftp</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>卸载软件包</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove ftp</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>列出软件包的依赖</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum deplist ftp</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>显示软件包的描述信息</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum info ftp</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>Cent OS</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>复制文件</title>
    <url>/2019/11/01/CentOs%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>Cent OS</tag>
        <tag>操作系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类和对象</title>
    <url>/2019/10/31/C-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="类和对象的进一步理解："><a href="#类和对象的进一步理解：" class="headerlink" title="类和对象的进一步理解："></a>类和对象的进一步理解：</h3><ol>
<li>在C++中对象的类型称为类（class）。类代表了某一批对象的共性和特征。</li>
<li>类是对象的抽象，而对象是类的具体实例(instance)。</li>
<li>在C++中先声明一个类的类型，然后具体用它去定义若干个同类型的对象。</li>
<li>对象就是类的这种类型的数据的一个变量。</li>
<li>类是抽象的，不占用内存，而对象是具体的，占用内存空间。</li>
<li>对象和类的关系相当于变量和变量类型的关系。</li>
</ol>
<a id="more"></a>

<h3 id="类的声明和类的使用："><a href="#类的声明和类的使用：" class="headerlink" title="类的声明和类的使用："></a>类的声明和类的使用：</h3><ol>
<li>使用关键字class</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名&#123;</span></span><br><span class="line"><span class="keyword">private</span>:<span class="comment">//私有成员</span></span><br><span class="line"><span class="comment">//数据成员，保存对象的属性</span></span><br><span class="line"><span class="comment">//函数成员，保存对象的动作</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//公共成员</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"id:"</span>&lt;&lt;id&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"name"</span>&lt;&lt;name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个学生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//在类里面声明函数，</span></span><br><span class="line"><span class="comment">//但太多的函数会使类显得臃肿</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inputStuInfo</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"input id,name,age"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;id&gt;&gt;name&gt;&gt;age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ouputStuInfo</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"name:"</span>&lt;&lt;name&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="string">"id:"</span>&lt;&lt;id&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="string">"age:"</span>&lt;&lt;age&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以在类外部声明一个函数</span></span><br><span class="line"><span class="keyword">void</span> Student::setId(<span class="keyword">int</span> id)&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;id=id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Student stu1;<span class="comment">//定义了一个学生对象；</span></span><br><span class="line">	</span><br><span class="line">	stu1.inputStuInfo();</span><br><span class="line">	stu1.outputStuInfo();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用类定义对象："><a href="#用类定义对象：" class="headerlink" title="用类定义对象："></a>用类定义对象：</h3><p>定义一个对象的三种方法：</p>
<ol>
<li>先声明类的类型，然后定义对象</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student stu1,stu2.<span class="comment">//Student是已经声明的对象</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在声明类的同时定义对象</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">&#125;stu1,stu2;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>不出现类名，直接定义对象(很少用)</li>
</ol>
<h3 id="对象指针与对象的动态创建于释放："><a href="#对象指针与对象的动态创建于释放：" class="headerlink" title="对象指针与对象的动态创建于释放："></a>对象指针与对象的动态创建于释放：</h3><p><strong>动态：</strong>用到对象时建立对象，不需要该对象时就释放该对象的内存空间<br>用new运算符创建对象，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Box *pt = <span class="keyword">new</span> Box;<span class="comment">//自动调用构造函数</span></span><br><span class="line"><span class="comment">//用pt访问新建的对象：</span></span><br><span class="line">	pt-&gt;height;</span><br><span class="line">	pt-&gt;getId();</span><br><span class="line">	</span><br><span class="line"><span class="comment">//用delete运算符释放对象：</span></span><br><span class="line">	<span class="keyword">delete</span> pt;<span class="comment">//释放对象之前自动调用析构函数</span></span><br></pre></td></tr></table></figure>

<h4 id="什么是对象指针？"><a href="#什么是对象指针？" class="headerlink" title="什么是对象指针？"></a>什么是对象指针？</h4><p>定义：类型为类的指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student stu;</span><br><span class="line">Student *pstu = <span class="literal">NULL</span>;</span><br><span class="line">pstu = &amp;stu;</span><br><span class="line">pstu-&gt;getId();</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者定义对象指针数组</span></span><br><span class="line">Student *pstus[<span class="number">10</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pstu;</span><br></pre></td></tr></table></figure>

<h3 id="类成员的访问属性："><a href="#类成员的访问属性：" class="headerlink" title="类成员的访问属性："></a>类成员的访问属性：</h3><p>public:公有的属性或者函数<br>private:私有的属性或函数，只能在类的内部访问<br>protected:受保护的属性或函数</p>
<h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><p>永远指向当前对象的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Student::setId(<span class="keyword">int</span> id)&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;id=id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Student::getId()&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类的构造函数和析构函数"><a href="#类的构造函数和析构函数" class="headerlink" title="类的构造函数和析构函数"></a>类的构造函数和析构函数</h3><ol>
<li>类的构造函数<br>一种特殊的成员函数。没有返回值，函数名与类名相同。类被初始化时，只被调用一次。<br>作用：一般用来初始化成员。</li>
</ol>
<ul>
<li>构造函数的声明：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Student();</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> type;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student::Student()&#123;</span><br><span class="line">	id=<span class="number">0</span>;</span><br><span class="line">	age=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::setId(<span class="keyword">int</span> id)&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;id=id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Student::getId()&#123;</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::setAge(<span class="keyword">int</span> age)&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;age=age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>类的析构函数</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++类和对象</tag>
        <tag>类，对象</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记</title>
    <url>/2019/10/24/%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>51单片机笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>C++函数回调</title>
    <url>/2019/10/23/C-%E5%87%BD%E6%95%B0%E5%9B%9E%E8%B0%83/</url>
    <content><![CDATA[<p>C++函数回调</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">populate_array</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">size_t</span> arraySize, <span class="keyword">int</span> (*getNextValue)(<span class="keyword">void</span>))</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;arraySize; i++)</span><br><span class="line">        <span class="built_in">array</span>[i] = getNextValue();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取随机值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNextRandomValue</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rand();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myarray[<span class="number">10</span>];</span><br><span class="line">    populate_array(myarray, <span class="number">10</span>, getNextRandomValue);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, myarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>函数回调</tag>
      </tags>
  </entry>
  <entry>
    <title>[转载]关于封装--一个有趣的C++例子</title>
    <url>/2019/10/23/%E8%BD%AC%E8%BD%BD-%E5%85%B3%E4%BA%8E%E5%B0%81%E8%A3%85-%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84C-%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<p>版权声明：本文为CSDN博主「zdleek」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/baodi_z/article/details/210432" target="_blank" rel="noopener">https://blog.csdn.net/baodi_z/article/details/210432</a></p>
<p>  一个有趣的现象，摘自CSDN 吹云Blog《C++从零开始（十二）——何谓面向对象编程思想》原文<a href="http://blog.csdn.net/chuiyun/archive/2004/11/26/194722.aspx。" target="_blank" rel="noopener">http://blog.csdn.net/chuiyun/archive/2004/11/26/194722.aspx。</a></p>
<a id="more"></a>
<pre><code>之所以摘录这段文章，是因为我奇怪下面的例子竟然真的能够编译通过--在引用的文件中篡改类的private为public就可以直接访问私有变量，而且能够正常访问和赋值。
下面是摘录的原文，有兴趣的朋友不妨也试试编个代码试验一下。</code></pre><hr>
<p>封装</p>
<pre><code>先来看现在在各类VC教程中关于对象的讲解中经常能看见的如下的一个类的设计。
class Person
{ private: char m_Name[20]; unsigned long m_Age; bool m_Sex;
  public:  const char* GetName() const;  void SetName( const char* );
           unsigned long GetAge() const; void SetAge( unsigned long );
           bool GetSex() const;          void SetSex( bool );
};
上面将成员变量全部定义为private，然后又提供三对Get/Set函数来存取上面的三个成员变量（因为它们是private，外界不能直接存取），这三对函数都是public的，为什么要这样？那些教材将此称作封装，是对类Person的内部内存布局的封装，这样外界就不知道其在内存上是如何布局的并进而可以保证内存的有效性（只由类自身操作其实例）。
首先要确认上面设计的荒谬性，它是正宗的“有门没锁”毫无意义。接着再看所谓的对内存布局的封装。回想在《C++从零开始（十）》中说的为什么每个要使用类的源文件的开头要包含相应的头文件。假设上面是在Person.h中的声明，然后在b.cpp中要使用类Person，本来要#include &quot;Person.h&quot;，现在替换成下面：
class Person
{ public: char m_Name[20]; unsigned long m_Age; bool m_Sex;
  public: const char* GetName() const;  void SetName( const char* );
          unsigned long GetAge() const; void SetAge( unsigned long );
          bool GetSex() const;          void SetSex( bool );
};
然后在b.cpp中照常使用类Person，如下：
Person a, b; a.m_Age = 20; b.GetSex();
这里就直接使用了Person::m_Age了，就算不做这样蹩脚的动作，依旧#include &quot;Person.h&quot;，如下：
struct PERSON { char m_Name[20]; unsigned long m_Age; bool m_Sex; };
Person a, b; PERSON *pP = ( PERSON* )&amp;a; pP-&gt;m_Age = 40;
上面依旧直接修改了Person的实例a的成员Person::m_Age，如何能隐藏内存布局？！请回想声明的作用，类的内存布局是编译器生成对象时必须的，根本不能对任何使用对象的代码隐藏有关对象实现的任何东西，否则编译器无法编译相应的代码。
那么从语义上来看。Person映射的不是真实世界中的人的概念，应该是存放某个数据库中的某个记录人员信息的表中的记录的缓冲区，那么缓冲区应该具备那三对Get/Set所代表的功能吗？缓冲区是缓冲数据用的，缓冲后被其它操作使用，就好像箱子，只是放东西用。故上面的三对Get/Set没有存在的必要，而三个成员变量则不能是private。当然，如果Person映射的并不是缓冲区，而在其它的世界中具备像上面那样表现的语义，则像上面那样定义就没有问题，但如果是因为对内存布局的封装而那样定义类则是大错特错的。
上面错误的根本在于没有理解何谓封装。为了说明封装，先看下MFC（Microsoft Foundation Class Library——微软功能类库，一个定义了许多类的库文件，其中的绝大部分类是封装设计。关于库文件在说明SDK时阐述）中的类CFile的定义。从名字就可看出它映射的是操作系统中文件的概念，但它却有这样的成员函数——CFile::Open、CFile::Close、CFile::Read、CFile::Write，有什么问题？这四个成员函数映射的都是对文件的操作而不是文件所具备的功能，分别为打开文件、关闭文件、从文件读数据、向文件写数据。这不是和前面说的成员函数的语义相背吗？上面四个操作有个共性，都是施加于文件这个资源上的操作，可以将它们叫做“被功能”，如文件具有“被打开”的功能，具有“被读取”的功能，但应注意它们实际并不是文件的功能。
按照原来的说法，应该将文件映射为一个结构，如FILE，然后上面的四个操作应映射成四个函数，再利用名字空间的功能，如下：
namespace OFILE
{
    bool Open( FILE&amp;, … );  bool Close( FILE&amp;, … );
    bool Read( FILE&amp;, … );  bool Write( FILE&amp;, … );
}
上面的名字空间OFILE表示里面的四个函数都是对文件的操作，但四个函数都带有一个FILE&amp;的参数。回想非静态成员函数都有个隐藏的参数this，因此，一个了不起的想法诞生了。
将所有对某种资源的操作的集合看成是一种资源，把它映射成一个类，则这个类的对象就是对某个对象的操作，此法被称作封装，而那个类被称作包装类或封装类。很明显，包装类映射的是“对某种资源的操作”，是一抽象概念，即包装类的对象都是无状态对象（指逻辑上应该是无状态对象，但如果多个操作间有联系，则还是可能有状态的，但此时它的语义也相应地有些变化。如多一个CFile::Flush成员函数，用于刷新缓冲区内容，则此时就至少有一个状态——缓冲区，还可有一个状态记录是否已经调用过CFile::Write，没有则不用刷新）。
现在应能了解封装的含义了。将对某种资源的操作封装成一个类，此包装类映射的不是世界中定义的某一“名词性概念”，而是世界的“动词性概念”或算法中“对某一概念的操作”这个人为定出来的抽象概念。由于包装类是对某种资源的操作的封装，则包装类对象一定有个属性指明被操作的对象，对于MFC中的CFile，就是CFile::m_hFile成员变量（类型为HANDLE），其在包装类对象的主要运作过程（前面的CFile::Read和CFile::Write）中被读。
有什么好处？封装提供了一种手段以将世界中的部分“动词性概念”转换成对象，使得程序的架构更加简单（多条“动词性概念”变成一个“名词性概念”，减少了“动词性概念”的数量），更趋于面向对象的编程思想。
但应区别开包装类对象和被包装的对象。包装类对象只是个外壳，而被包装的对象一定是个具有状态的对象，因为操作就是改变资源的状态。对于CFile，CFile的实例是包装类对象，其保持着一个对被包装对象——文件内核对象（Windows操作系统中定义的一种资源，用HANDLE的实例表征）——的引用，放在CFile::m_hFile中。因此，包装类对象是独立于被包装对象的。即CFile a;，此时a.m_hFile的值为0或-1，表示其引用的对象是无效的，因此如果a.Read( … );将失败，因为操作施加的资源是无效的。对此，就应先调用a.Open( … );以将a和一特定的文件内核对象绑定起来，而调用a.Close( … );将解除绑定。注意CFile::Close调用后只是解除了绑定，并不代表a已经被销毁了，因为a映射的并不是文件内核对象，而是对文件内核对象操作的包装类对象。
如果仔细想想，就会发现，老虎能够吃兔子，兔子能够被吃，那这里应该是老虎有个功能是“吃兔子”还是多个兔子的包装类来封装“吃兔子”的操作？这其实不存在任何问题，“老虎吃兔子”和“兔子被吃”完全是两个不同的操作，前者涉及两种资源，后者只涉及一种资源，因此可以同时实现两者，具体应视各自在相应世界中的语义。如果对于真实世界，则可以简略地说老虎有个“吃”的功能，可以吃“肉”，而动物从“肉”和“自主能动性”多重继承，兔子再从动物继承。这里有个类叫“自主能动性”，指动物具有意识，能够自己动作，这在C++中的表现就是有成员函数的类，表示有功能可以被操作，但收音机也具有调台等功能，难道说收音机也能自己动？！这就是世界的意义——运转。</code></pre><p>————————————————</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>封装</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象和面向过程</title>
    <url>/2019/10/22/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>转载：</p>
<h3 id="面向过程编程："><a href="#面向过程编程：" class="headerlink" title="面向过程编程："></a>面向过程编程：</h3><p><strong>关注的是问题的解决的过程步骤（事情是如何解决的），算法</strong></p>
<h3 id="面向对象编程："><a href="#面向对象编程：" class="headerlink" title="面向对象编程："></a>面向对象编程：</h3><p><strong>关注的是解决问题的人（类），具备什么样的数据（成员变量），具备什么样的技能（成员函数）才能解决问题</strong></p>
<a id="more"></a>
<p>** 抽象：<strong>找出一个能解决问题的”对象”（观察研究对象），找出解决问题所必须的数据（属性），功能（成员函数）<br>**封装：</strong>把抽象的结构，归结为一个类（数据类型），然后实例化出类对象，设置对象的属性，调用对象的功能达到解决问题的目的<br><strong>继承：</strong>在解决问题前先寻找之前的类能不能解决问题，或解决部分问题，如果可以，则把旧的类型继承后再次扩展，来缩短解决问题的时间，降低解决问题的难度。<br><strong>多态：</strong>对象的多种形态，外部看到一个对象（父亲），当我们向对象发出指令，对象会根据自身情况做出独特反应</p>
<h3 id="一、类和对象"><a href="#一、类和对象" class="headerlink" title="一、类和对象"></a>一、类和对象</h3><ol>
<li>通过分析“对象”的属性和行为设计出一个类</li>
<li>类就是数据类型<br>简单类型：只能表示一个属性（变量），C/C++内建数据类型<br>数组类型：可以表示多个属性（变量），类型必须相同<br>结构类型：可以表示多个属性（变量），但缺少行为（函数）<br>类类型：既能表示属性（变量），也能表示行为，一种复合的数据类型</li>
<li>对象就是类这种数据类型创建出来的实例，相当于结构变量<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="comment">//成员函数</span></span><br><span class="line">&#125;；</span><br><span class="line">Student stu;<span class="comment">//(类对象)</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="二、类的定义于初始化"><a href="#二、类的定义于初始化" class="headerlink" title="二、类的定义于初始化"></a>二、类的定义于初始化</h3><ol>
<li><p>类的一般形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名：继承方式 父类&#123;</span></span><br><span class="line"><span class="keyword">public</span>/<span class="keyword">private</span>/<span class="keyword">protected</span>:<span class="comment">//访问控制限制符</span></span><br><span class="line">成员变量</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">类名(形参表)&#123;&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~类名(<span class="keyword">void</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类的访问控制限定符</p>
</li>
</ol>
<p><strong>public</strong>：公有成员，在任何位置都能访问<br><strong>private</strong>：私有成员，只能被自己类的成员函数访问<br><strong>protracted</strong>：受保护成员，只能在自己类和子类中访问<br>注意：类中的成员变量、成员函数默认是private(私有的)，结构体中的成员变量、成员函数默认是public(公有的)；<strong>C++中类和结构的区别只有成员函数和成员变量默认访问权限不同</strong></p>
<ol start="3">
<li>构造函数</li>
</ol>
<ul>
<li>什么是构造函数？<strong>类的同名函数就是构造函数，没有返回值</strong></li>
<li>什么时候被调用？被谁调用？调用几次？<strong>创建类对象时会被自动调用（每创建一个对象就被调用一次），整个生命周期中一定会被调用一次，只能调用一次</strong></li>
<li>负责干什么，有什么用？成员变量的初始化，分配相关资源，设置对象的初始化状态</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名：继承方式 父类&#123;</span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">类名(形参表)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>对象创建过程</li>
</ol>
<ul>
<li>分配类型所需要的空间，无论是栈还是堆</li>
<li>传递实参调用构造函数，完成如下任务<br>1、根据继承表依次调用父类的构造函数<br>2、根据成员变量的顺序依次调用成员变量的构造函数<br>3、执行构造函数中的代码</li>
<li><em>注意：执行构造函数的代码是整个构造函数的最后一步，要保证构造函数代码所需的一切资源和先决条件在该代码执行前已经准备充分，并得到正确的初始化。*</em></li>
</ul>
<ol start="5">
<li>对象的创建方法</li>
</ol>
<ul>
<li><p><strong>在栈上创建：</strong><br><font color="#ff0000">类名+对象;</font>//若为空则不需要（）<br>或 <font color="#ff0000">类名+对象（实参）;</font></p>
</li>
<li><p><strong>在堆上创建：</strong><br><font color="#ff0000">类名*对象指针 = new 类名；</font><br>或 <font color="#ff0000">类名*对象指针 = new 类名（实参）；</font></p>
</li>
<li><p><strong>创建多个对象：</strong></p>
<p><font color="#ff0000">类名 对象={(实参),(实参),(实参)}</font></p>
<p><font color="#ff0000">类名*对象指针=new 类名[n]{(实参),(实参),(实参)}</font></p>
</li>
</ul>
<p><strong>注意：通过malloc创建的类对象不能调用构造函数，通过new创建的对象，一定要通过delete释放</strong></p>
<ol start="6">
<li><p>类的声明、实现、调用</p>
<ul>
<li><p>在头文件中声明</p>
</li>
<li><p>源文件实现类的相关函数</p>
</li>
</ul>
</li>
</ol>
<p>调用时只需要导入头文件，然后与类函数所在的源文件一起编译即可</p>
<p><strong>注意：如果一个类的内容不多，可以考虑在头文件中完全实现，也可以只在头文件实现一些简单的成员函数；类中自动生成的函数，在头文件中实现时，也需要在头文件中声明</strong></p>
<h3 id="三、构造函数与初始化列表"><a href="#三、构造函数与初始化列表" class="headerlink" title="三、构造函数与初始化列表"></a>三、构造函数与初始化列表</h3><ol>
<li>构造函数可以被重载（同一个名字的函数有多个版本）</li>
<li>（缺省构造）无参构造，编译器自动生成的一个什么都不做的构造函数，只是用来避免编译错误<strong>注意：当类中实现有参构造后，无参构造不会自动生成，有需要必须手动写出来</strong></li>
<li>无参构造未必无参，当给有参构造设置默认形参，调用这个函数时就不需要传参</li>
</ol>
<p><strong>注意：1、所谓的“编译器生成的XXXX函数”其实并不是正真语法上的函数，而是功能意义上的函数，编译器作为可执行指令的生产者，它会直接生成具有某项功能的二进制指令，不需要借助高级语言语义上的函数完成任务。2、如果一个类A是其他类成员变量，那么一定要保证它有一个无参变量，当B的构造函数执行时，会先执行成员变量的构造函数，而此时类B是无法给类A成员变量提供参数的。</strong></p>
<ol start="4">
<li><p>单参构造与类型转换<br>如果构造函数只有一个，那么可能Text t=n;语句就不会出错，它会自动调用单参构造来达到类型转换的效果，如果想禁止这种类型转换需要在单参构造前加<kbd>explicit</kbd></p>
</li>
<li><p>初始化列表</p>
</li>
</ol>
<p>为类成员进行初始化用的。<br>对const成员初始化的方法<br>构造函数（参数）：成员1（参数），成员2（参数）·····<br>通过初始化列表可以给类成员变量传递参数，以此调用类成员的有参构造<br>初始化列表也可以给const成员、引用成员进行初始化</p>
<p><strong>注意：成员的初始化顺序与初始化列表没有关系，而是与在类中的定义顺序有关<br>注意：初始化列表运行类成员变量还没有定义成功</strong></p>
]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象</tag>
        <tag>面向过程</tag>
        <tag>编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual-Studio常用快捷键</title>
    <url>/2019/10/22/Visual-Studio%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<ol>
<li>项目相关的快捷键<br>Ctrl + Shift + B = 生成项目<br>Ctrl + Alt + L = 显示Solution Explorer（解决方案资源管理器）<br>Shift + Alt+ C = 添加新类<br>Shift + Alt + A = 添加新项目到项目</li>
</ol>
<a id="more"></a>
<ol start="2">
<li>编辑相关的键盘快捷键<br>Ctrl + Enter = 在当前行插入空行<br>Ctrl + Shift + Enter = 在当前行下方插入空行<br>Ctrl +空格键 = 使用IntelliSense（智能感知）自动完成<br>Alt + Shift +箭头键(←,↑,↓,→) = 选择代码的自定义部分<br>Ctrl + } = 匹配大括号、括号<br>Ctrl + Shift +} = 在匹配的括号、括号内选择文本<br>Ctrl + Shift + S = 保存所有文件和项目<br>Ctrl + K，Ctrl + C = 注释选定行<br>Ctrl + K，Ctrl + U = 取消选定行的注释<br>Ctrl + K，Ctrl + D = 正确对齐所有代码<br>Shift + End = 从头到尾选择整行<br>Shift + Home = 从尾到头选择整行<br>Ctrl + Delete = 删除光标右侧的所有字</li>
<li>导航相关的键盘快捷键<br>Ctrl +Up/Down = 滚动窗口但不移动光标<br>Ctrl + - = 让光标移动到它先前的位置<br>Ctrl ++ = 让光标移动到下一个位置<br>F12 = 转到定义</li>
<li>调试相关的键盘快捷键<br>Ctrl + Alt + P = 附加到进程<br>F10 = 调试单步执行<br>F5 = 开始调试<br>Shift + F5 = 停止调试<br>Ctrl + Alt + Q = 添加快捷匹配<br>F9 = 设置或删除断点</li>
<li>搜索相关的键盘快捷键<br>Ctrl + K Ctrl + K = 将当前行添加书签<br>Ctrl + K Ctrl + N = 导航至下一个书签<br>Ctrl + . = 如果你键入一个类名如Collection，且命名空间导入不正确的话，那么这个快捷方式组合将自动插入导入<br>Ctrl + Shift + F = 在文件中查找<br>Shift + F12 = 查找所有引用<br>Ctrl + F = 显示查找对话框<br>Ctrl + H = 显示替换对话框<br>Ctrl + G = 跳转到行号或行<br>Ctrl + Shift + F = 查找所选条目在整个解决方案中的引用</li>
</ol>
]]></content>
      <categories>
        <category>Visual Studio</category>
      </categories>
      <tags>
        <tag>Visual Studio</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>常用寄存器</title>
    <url>/2019/10/20/%E5%B8%B8%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[<h3 id="EAP"><a href="#EAP" class="headerlink" title="EAP"></a>EAP</h3>]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>寄存器</tag>
        <tag>汇编指令</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编常用指令</title>
    <url>/2019/10/19/%E6%B1%87%E7%BC%96%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>没有代码量的人很难懂代码的复用，实质上，所有面向对象的语言，它的出发点只有一个，它的本质只有一个，减少代码的重复，增加代码的复用。</p>
<p>堆栈：特殊地内存区</p>
<p>加法减法没有本质区别</p>
<p>不存在进位</p>
<p>明确数据宽度</p>
<h3 id="MOV"><a href="#MOV" class="headerlink" title="MOV:"></a>MOV:</h3><p>MOV EAP,ESP<br>MOV EAP,DWORD PTR DS:[0X00ff00ff]</p>
<h3 id="SUB"><a href="#SUB" class="headerlink" title="SUB:"></a>SUB:</h3><h3 id="PUSH"><a href="#PUSH" class="headerlink" title="PUSH:"></a>PUSH:</h3><p><strong>作用</strong>：将数据压入堆栈，并且将栈顶指针向上移动相应的位数。<br>比如<kbd>PUSH AX</kbd>，AX是<font color="#ff0000">16</font>位的，每个内存单元是一字节，即<font color="#ff0000">8</font>位，所以将十六位的AX存入堆栈时，会占用堆栈<font color="#ff0000">16位（即2字节）</font>的空间，所以栈顶指针要向上移动<font color="#ff0000">2</font>位，即ESP减少<font color="#ff0000">4</font>；再比如<kbd>PUSH EAX</kbd>，表示将<font color="#ff0000">32</font>位的EAX中的数据压入堆栈中，这些数据去将占用<font color="#ff0000">32/8=4</font>个内存单元，所以栈顶指针要向上移动<font color="#ff0000">4</font>位。</p>
<a id="more"></a>

<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUSH r32</span><br><span class="line">PUSH r16</span><br><span class="line">PUSH m16</span><br><span class="line">PUSH m32</span><br><span class="line">PUSH imm8/imm16/imm32</span><br><span class="line"></span><br><span class="line">PUSH WORD PTR DS:[12FFDA] </span><br><span class="line">//WORD 表示该内存是两字节的，所以执行这条指令时，</span><br><span class="line">//栈顶指针向上移动2位。</span><br><span class="line"></span><br><span class="line">PUSH DWORD PTR DS:[12FFDA]</span><br><span class="line">//DWORD 表示该内存是4字节的，所以执行这条1指令时，</span><br><span class="line">//栈顶指针向上移动4位。</span><br></pre></td></tr></table></figure>

<p>注意：不允许PUSH r8，为什么？因为官方没有定义这条指令</p>
<h3 id="POP"><a href="#POP" class="headerlink" title="POP:"></a>POP:</h3><p><strong>作用</strong>：从堆栈中取值，放入容器中。</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POP r32</span><br><span class="line">POP r16</span><br><span class="line">POP m16</span><br><span class="line">POP m32</span><br></pre></td></tr></table></figure>

<h3 id="PUSHAD"><a href="#PUSHAD" class="headerlink" title="PUSHAD:"></a>PUSHAD:</h3><p><strong>作用</strong>：将寄存器中的值全部压入堆栈，可以形象地理解为“保护现场”。</p>
<h3 id="POPAD"><a href="#POPAD" class="headerlink" title="POPAD:"></a>POPAD:</h3><p><strong>作用</strong>：PUSHAD压入堆栈的值全部取出来，重新放入寄存器，可以形象地理解为“恢复现场”。</p>
<h3 id="逆向汇编学习路程"><a href="#逆向汇编学习路程" class="headerlink" title="逆向汇编学习路程"></a>逆向汇编学习路程</h3><ol>
<li>学习PE，PE结构对学习指针非常有好处</li>
<li>下断点</li>
<li>win32 api</li>
<li>什么是函数堆栈</li>
<li>熟悉堆栈-画堆栈图</li>
<li>CALL是什么，JE是什么，标志寄存器是什么</li>
<li>c语言的逆向</li>
</ol>
<h3 id="EFLAGS标志寄存器"><a href="#EFLAGS标志寄存器" class="headerlink" title="EFLAGS标志寄存器"></a>EFLAGS标志寄存器</h3><p>EFLAGS标志寄存器，简称EFL寄存器，里面存储一个32位的值，其中每一位都有不同的意义。</p>
<p>划重点，考试会考，背下来</p>
<table>
<thead>
<tr>
<th align="center">31</th>
<th align="center">…</th>
<th align="center">22</th>
<th>21</th>
<th>20</th>
<th>19</th>
<th>18</th>
<th>17</th>
<th>16</th>
<th align="center">15</th>
<th align="center">14</th>
<th align="center">13</th>
<th align="center">12</th>
<th align="center">11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td align="center">0</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>查看DTDEBUG中的EFLAGS的值，然后转换成二进制，并取出CF/PF/AF/ZF/SF/OF的值</p>
<p>记住这几个寄存器的名称</p>
<ol>
<li>进位标志CF(Carry Flag)：如果运算结果的最高位产生了一个<font color="#ff0000">进位或者借位</font>，那么，其值为<font color="#ff0000">1</font>，否则为<font color="#ff0000">0</font>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MOV EAX,<span class="number">5555F</span>FFF</span><br><span class="line">ADD EAX,<span class="number">1</span></span><br><span class="line"><span class="comment">//运算后EAX==55560000</span></span><br><span class="line"><span class="comment">//EAX最高位数据没有产生变化，CF标志位不变</span></span><br><span class="line"></span><br><span class="line">MOV AL,<span class="number">0XFF</span><span class="comment">//EAX==555600FF，AL明确数据宽度，CF只检查8位数据</span></span><br><span class="line">ADD AL,<span class="number">1</span></span><br><span class="line"><span class="comment">//EAX中的8位寄存器进行+1操作，</span></span><br><span class="line"><span class="comment">//奈何EAX中的AX已是满数据，所以+1后会发生数据溢出，</span></span><br><span class="line"><span class="comment">//溢出的数据保存在CF标志位中</span></span><br><span class="line"><span class="comment">//运算后EAX==55560000</span></span><br><span class="line"><span class="comment">//AX最高位发生变化，CF标志位改变为1</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>奇偶标志位PF(Parity Flag)：奇偶标志PF用于反映运算结果中“1”的个数的奇偶性，如果“1”的个数为偶数，则PF的值为1，否则为0。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MOV AL,<span class="number">3</span><span class="comment">//0000 0011</span></span><br><span class="line">ADD AL,<span class="number">3</span><span class="comment">//0000 0011--&gt;0000 0110，有两个1，奇标志位PF变成1</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>辅助进位标志AF(Auxiliary Carry Flag)：在发生下列情况时，辅助进位标志AF的值改变为1，否则为0。<ul>
<li>在字操作时，发生低字节向高字节进位或借位时；</li>
<li>在字节操作时，发生低4位向高4位进位或借位时。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MOV EAX,<span class="number">0X55EEFFFF</span></span><br><span class="line">ADD EAX,<span class="number">2</span><span class="comment">//AF发生变化，改变为1</span></span><br><span class="line"></span><br><span class="line">MOV AX,<span class="number">5</span>EFE</span><br><span class="line">ADD AX,<span class="number">2</span><span class="comment">//AF变为1</span></span><br><span class="line"></span><br><span class="line">MOV AL,<span class="number">4</span>E</span><br><span class="line">ADD AL,<span class="number">2</span><span class="comment">//A不变</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>零标志位(Zero Flag)：零标志ZF用来反映运算结果是否为0。如果运算结果为0，其值为1，否则为0。此标志位可用于判断运算结果是否为0。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">XOR EAX,EAX</span><br><span class="line"></span><br><span class="line">MOV EAX,<span class="number">2</span></span><br><span class="line">SUB EAX,<span class="number">2</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>符号标志位</li>
</ol>
]]></content>
      <categories>
        <category>汇编学习</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>汇编指令</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言指针</title>
    <url>/2019/10/18/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h3 id="C语言指针的一些实例"><a href="#C语言指针的一些实例" class="headerlink" title="C语言指针的一些实例"></a>C语言指针的一些实例</h3><h4 id="指针直接对参数进行操作"><a href="#指针直接对参数进行操作" class="headerlink" title="指针直接对参数进行操作"></a>指针直接对参数进行操作</h4><p>C语言指针的存在，使得C语言对硬件的操纵，以及灵活性得到了极大的提高。</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//弥补c语言只能有一个返回值的特性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *pa,<span class="keyword">int</span> *pb)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t = *pa;</span><br><span class="line">	*pa = *pb;</span><br><span class="line">	*pb = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">15</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//当初始化一个变量同时用*标记时，说明该变量是一个指针</span></span><br><span class="line">    <span class="comment">//比如</span></span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,a,b);</span><br><span class="line">	swap(&amp;a, &amp;b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %d"</span>, a, b);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span>* p = a;<span class="comment">//无需用&amp;取址符</span></span><br><span class="line">	<span class="comment">//但数组变量表示的是变量，要用取址符。</span></span><br><span class="line">	<span class="keyword">int</span>* p2 = &amp;a[<span class="number">3</span>];<span class="comment">//获取a数组里第四个变量的地址，也就所谓指针。</span></span><br><span class="line">	<span class="comment">//[]可以对数组做，也可以对指针做。</span></span><br><span class="line">	<span class="comment">//所以p[0]==a[0]   --&gt;true</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[<span class="number">0</span>]);<span class="comment">//print 1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, a[<span class="number">0</span>]);<span class="comment">//print 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="用const修饰的指针"><a href="#用const修饰的指针" class="headerlink" title="用const修饰的指针"></a>用const修饰的指针</h4><p>const翻译过来就是常量的意思，用它标识某一变量后，这个变量在后面的程序无法修改。<br>比如<font color="#ff0000">int const a=10;</font>，之后再对a重新赋值会报<font color="#ff0000">ERROR!</font></p>
<ol>
<li><p>const在* 之后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">2001</span>;</span><br><span class="line">	<span class="comment">//const 标识指针pi是常量，是不能被修改的。</span></span><br><span class="line">	<span class="comment">//但pi指向的值是可以改变的</span></span><br><span class="line">	<span class="keyword">int</span>* <span class="keyword">const</span> pi = &amp;i;</span><br><span class="line">	*pi = <span class="number">2000</span>;<span class="comment">//no problem</span></span><br><span class="line">	pi++;<span class="comment">//error</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>const在*之前：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">2001</span>;</span><br><span class="line">	<span class="keyword">int</span> ai = <span class="number">2000</span>;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">const</span>* pi = <span class="literal">NULL</span>;</span><br><span class="line">	pi=&amp;ai;<span class="comment">//no problem</span></span><br><span class="line">	*pi = <span class="number">1999</span>;<span class="comment">//Error</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, *pi);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>总结：当<kbd>const</kbd>位于*<font color="#ff0000">之后</font>，说明这是一个常量的指针；当<kbd>const</kbd>位于*<font color="#ff0000">之前</font>，说明这是一个常量。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p; <span class="comment">//这是一个普通的整型变量  </span></span><br><span class="line"><span class="keyword">int</span> *p; <span class="comment">//首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针  </span></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组  </span></span><br><span class="line"><span class="keyword">int</span> *p[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组  </span></span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>]; <span class="comment">//首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与"()"这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针  </span></span><br><span class="line"><span class="keyword">int</span> **p; <span class="comment">//首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据  </span></span><br><span class="line">Int (*p)(<span class="keyword">int</span>); <span class="comment">//从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针  </span></span><br><span class="line"><span class="keyword">int</span> *(*p(<span class="keyword">int</span>))[<span class="number">3</span>]; <span class="comment">//可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2019/10/18/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h3 id="将一个整数转化为二进制"><a href="#将一个整数转化为二进制" class="headerlink" title="将一个整数转化为二进制"></a>将一个整数转化为二进制</h3><p>（这里用的是C语言，最近在学c语言。）关键主要是使用按位与<font color="#ff0000">&amp;</font>这种运算。</p>
<a id="more"></a>

<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">32</span>;<span class="comment">//左移位数。 </span></span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;<span class="comment">//判断第一位是否为零，如果是零则不输出。 </span></span><br><span class="line">    <span class="keyword">int</span> bit=<span class="number">0</span>;<span class="comment">//用于临时存储二进制位。</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="number">0</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">while</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    index--;</span><br><span class="line">    	bit=n&amp;(<span class="number">1</span>&lt;&lt;index)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">if</span>(bit!=<span class="number">0</span>)</span><br><span class="line">    		flag=<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">    		<span class="built_in">printf</span>(<span class="string">"%d"</span>,bit);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>位运算</tag>
        <tag>二进制</tag>
        <tag>高效运算</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机最小系统</title>
    <url>/2019/10/17/%E5%8D%95%E7%89%87%E6%9C%BA%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/dpjzxxt.jpg">

<a id="more"></a>

<p>周四，晚上，8.20，<font color="#00ff00">电子楼S109</font>，单片机最小系统，终于焊好了！<br>首先感谢漂亮的师兄师姐的 <del>淳淳教导</del> 耐心教导，不然是不可能徒手撸单片机的hhhhh…</p>
<p>听说Markdown支持直接使用<kbd>Html</kbd>标签？今晚顺便试试，比如<font color="#ff00ff">这样</font></p>
<h3 id="晶振"><a href="#晶振" class="headerlink" title="晶振"></a>晶振</h3><img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/jz.jpg">
<p>原来这就是晶振，摸起来冰冰凉凉的，真的是太有金属感了（–^ -^-<del>这原本不就是金属吗？</del>）<br>它的作用？师姐说它是单片机的心脏，虽然我知道这是骗人的，单片机怎么可能有<font color="#ff0000">心脏</font>呢? 不过真形象的比喻，emmmm目前我的理解就是它为单片机里的虚拟世界提供一个时间，驱动单片机运行。</p>
<h3 id="今晚的电路图"><a href="#今晚的电路图" class="headerlink" title="今晚的电路图"></a>今晚的电路图</h3><p>眼花缭乱</p>
<img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/dlt.png">
<p>听说<font color="#ff0000">发光二极管</font>画错了？师姐的错，（嘿嘿嘿）不过师姐<font color="#000000">很可爱地</font>道歉了。</p>
<h3 id="六角自锁开关"><a href="#六角自锁开关" class="headerlink" title="六角自锁开关"></a>六角自锁开关</h3><p>不拍实物图了（<del>懒</del>）原理图代替，就假装看到了实物图</p>
<img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/ljkg.jpg">

<h3 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h3><p>第一个手撸单片机，相信以后还会有第二个，第三个，emmmm，不过头发是个问题</p>
<img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/dpj.jpg">
<p>一个小时你焊得完吗？<br>大脑：可以的，肯定可以。<br>手：你放屁<br>啊啊啊还差一点，差一点就焊完了。。焊完后连接电脑烧入程序就可以运行了。<br>又成功水了一天</p>
]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>绝对值不等式</title>
    <url>/2019/10/15/%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F/</url>
    <content><![CDATA[<p>$$<br>||a|-|b||&lt;=|a+b|&lt;=|a|+|b|<br>$$</p>
<p>$$<br>||a|-|b||&lt;=|a-b|&lt;=|a|+|b|<br>$$</p>
<p>$$<br>sin x &lt; x &lt; tan x   </p>
<p>0&lt;x&lt;(pi/2)<br>$$</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>高数</tag>
        <tag>绝对值</tag>
        <tag>不等式</tag>
      </tags>
  </entry>
  <entry>
    <title>编码系统原理</title>
    <url>/2019/10/14/%E7%BC%96%E7%A0%81%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>C语言运算符优先级</title>
    <url>/2019/10/13/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/webyou2.png">

<a id="more"></a>

<h3 id="C语言运算符"><a href="#C语言运算符" class="headerlink" title="C语言运算符"></a>C语言运算符</h3><p>c语言有丰富的运算符，但是一串加起来怕是会把你搞懵。每次看到别人这样写自己总是一阵懵，虽说这样写代码的应该拉出去打死，不过看起来确实挺Cool的………废话不多说，开始撸代码~</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*p += *p &gt;= <span class="string">'a'</span> ? *p + *k &gt; <span class="string">'z'</span> ? *k - <span class="number">26</span> : *k : *p + *k &gt; <span class="string">'Z'</span> ? *k - <span class="number">26</span> : *k;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h4><p><kbd>+</kbd>、<kbd>-</kbd>、<kbd>*</kbd>、<kbd>/</kbd></p>
<p><kbd>a=a+b;</kbd>可以写成<kbd>a+=b;</kbd>、<kbd>a=a*b;</kbd>可以写成<kbd>a*=b;</kbd></p>
<p>但当写成<kbd>a*=b+2;</kbd>实际执行的是<kbd>a=a*(b+2);</kbd></p>
<p><strong>a*=b;只是一种书写形式，并不会影响到程序执行效率</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line">	a*=b+<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出40</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO搭建博客全攻略</title>
    <url>/2019/10/12/HEXO%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%85%A8%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/web2.jpg">

<a id="more"></a>



<h3 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h3><ul>
<li><p>git（推荐官网下载，或者点击<a herf="https://www.lanzous.com/i6su13i ">这里</a>下载Git2.23.0-64bit.</p>
</li>
<li><p>github账号(没有的话去<a herf="https://www.github.com">注册</a>一个)</p>
</li>
<li><p>安装了node.js、npm</p>
</li>
<li><p>域名（可选）</p>
</li>
</ul>
<h3 id="能学到什么"><a href="#能学到什么" class="headerlink" title="能学到什么"></a>能学到什么</h3><ol>
<li>github的使用，如何用GitHub维护一个项目</li>
<li>git命令行</li>
<li>使用markdown写文章 </li>
<li>域名是什么</li>
</ol>
<h3 id="在github上创建仓库"><a href="#在github上创建仓库" class="headerlink" title="在github上创建仓库"></a>在github上创建仓库</h3><ol>
<li>注册GitHub账号，注意：邮箱必须验证</li>
<li>新建一个名为<kbd>你的用户名.github.io</kbd>的仓库，比如，你的用户名是mnt，那么你就新建<kbd>mnt.github.io</kbd>的仓库，其他的名称无效，以后访问你博客的地址就是<a href="http://mnt.github.io" target="_blank" rel="noopener">http://mnt.github.io</a></li>
</ol>
<h3 id="导航栏添加分类和标签"><a href="#导航栏添加分类和标签" class="headerlink" title="导航栏添加分类和标签"></a>导航栏添加分类和标签</h3><p>实现如下分类和标签的功能：</p>
<img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/dhl.jpg">

<p>点击分类后的界面：</p>
<img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/fl.jpg">

<p>点击标签后的界面：</p>
<img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/bq.jpg">

<h5 id="创建”分类”选项"><a href="#创建”分类”选项" class="headerlink" title="创建”分类”选项"></a>创建”分类”选项</h5><ol>
<li>生成分类界面</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>

<p>成功后会提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ INFO  Created: D:\blog\<span class="built_in">source</span>\categories\index.md</span><br></pre></td></tr></table></figure>

<p>根据上面的路径，找到<kbd>index.md</kbd>这个文件，打开后默认内容是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-10-13 16:13:06</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>添加<kbd>type: "categories"</kbd>到内容中，添加后是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-10-13 16:13:06</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"categories"</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>关闭并保存文件。<br>2. 给文章添加<kbd>catepories</kbd>属性。<br>下方的<kbd>catepories: Hexo</kbd>搭建博客 表示添加这篇文章到”Hexo搭建博客”这个分类。注意：<strong>hexo中的一篇文章只能属于一个分类。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: HEXO搭建博客全攻略</span><br><span class="line">date: 2019-10-12 11:23:12</span><br><span class="line">tags: 博客</span><br><span class="line"> - Hexo</span><br><span class="line">categories: Hexo搭建博客</span><br></pre></td></tr></table></figure>

<p>至此，成功给文章添加分类，点击首页的“分类”可以看到该文章下的所有文章。当然，只有添加了<kbd>categories: xxxx</kbd> 的文章才会被收录进来。</p>
<h5 id="创建“标签”选项"><a href="#创建“标签”选项" class="headerlink" title="创建“标签”选项"></a>创建“标签”选项</h5><ol>
<li>生成“标签”</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>

<p>成功后会提示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO Created: D:\blog\<span class="built_in">source</span>\tags\index.md</span><br></pre></td></tr></table></figure>

<p>根据上面的路劲，找到<kbd>index.md</kbd>这个文件打开后默认内容是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2017-05-27 14:22:08</span><br></pre></td></tr></table></figure>

<p>添加<kbd>type: "tags"</kbd>到内容中，添加后是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2017-05-27 14:22:08</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"tags"</span></span><br></pre></td></tr></table></figure>

<p>保存并关闭文件。</p>
<ol start="2">
<li>给文章添加”tags”属性：<br>打开需要添加标签的文章，为其添加”tags”属性,下方的<kbd>博客</kbd>、<kbd>Hexo</kbd>就是这篇文章的tags了。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: HEXO搭建博客全攻略</span><br><span class="line">date: 2019-10-12 11:23:12</span><br><span class="line">tags: </span><br><span class="line"> - 博客</span><br><span class="line"> - Hexo</span><br><span class="line">categories: Hexo搭建博客</span><br></pre></td></tr></table></figure>

<p>至此，成功添加给文章“标签”属性。</p>
<p>细心的朋友可能会发现，这两者的设置几乎一模一样！是的，没错，思路是一样的。所以我们可以打开scaffolds/post.md 文件，在<kbd>tages: </kbd>上面加入<kbd>categories: </kbd>，保存后执行 <kbd>hexo new 文章名</kbd> 命令生成的文件，页面里就有<kbd>categories: </kbd>项了。</p>
<p><kbd>scaffolds</kbd>目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里设置你自己的一些默认值。</p>
<h3 id="图片点击实现全屏查看"><a href="#图片点击实现全屏查看" class="headerlink" title="图片点击实现全屏查看"></a>图片点击实现全屏查看</h3><h5 id="方法1-使用fancybox插件"><a href="#方法1-使用fancybox插件" class="headerlink" title="方法1.使用fancybox插件"></a>方法1.使用<kbd>fancybox</kbd>插件</h5><ol>
<li>切换到lib目录：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> next/<span class="built_in">source</span>/lib</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>下载<kbd>fancybox</kbd>插件：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-fancybox3 fancybox</span><br></pre></td></tr></table></figure>

<img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/gitfancybox.jpg">

<ol start="3">
<li><p>更改主题配置文件：</p>
<p><strong>主题(比如next)/_config.yml</strong></p>
</li>
</ol>
<p>打开主题文件夹下<kbd>_config.yml</kbd> 作以下更改：(注意”:”后有且只有一个空格)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fancybox: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>生成，本地测试</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/zs.jpg">
<p>OK 简直完美~</p>
]]></content>
      <categories>
        <category>Hexo搭建博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>常用网站，你懂的</title>
    <url>/2019/10/12/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99%EF%BC%8C%E4%BD%A0%E6%87%82%E7%9A%84/</url>
    <content><![CDATA[<img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/webyou.png">

<a id="more"></a>



<p><strong>老司机常用网站~备忘，持续更新哇，（右侧目录，预览全场）</strong></p>
<p>无情分割线</p>
<hr>
<h3 id="搜索引擎-："><a href="#搜索引擎-：" class="headerlink" title="搜索引擎 ："></a>搜索引擎 ：</h3><p>   在网络资源泛滥的时代，作为一名合格的<del>老司机</del>，怎能没有一款强大的搜索工具呢？神器奉上：</p>
<h5 id="密迹搜索"><a href="#密迹搜索" class="headerlink" title="密迹搜索"></a><a href="https://mijisou.com" target="_blank" rel="noopener">密迹搜索</a></h5><p>一款超级良心、无敌安全的搜索引擎，不会搜集私人信息，也没有Cookie，并且聚合了 <strong>百度、360、Bing、搜狗等搜索结果。</strong></p>
<img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/mijisou.png">

<h5 id="小白盘"><a href="#小白盘" class="headerlink" title="小白盘"></a><a href="https://www.xiaobaipan.com" target="_blank" rel="noopener">小白盘</a></h5><p>   资源搜索，检索度盘等资源，可以搜索电影，电视剧，小说，音乐等资源，无毒，界面清新。</p>
<img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/xbp.jpg">

<h3 id="PPT"><a href="#PPT" class="headerlink" title="PPT"></a>PPT</h3><h5 id="优品PPT"><a href="#优品PPT" class="headerlink" title="优品PPT"></a><a href="http://www.ypppt.com" target="_blank" rel="noopener">优品PPT</a></h5><p>   目前全免费，点击即可下载，无需登录，少量广告，不影响阅读。最重要的是PPT质量非常高。</p>
<img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/ypppt.jpg">

<h5 id="中国色配色网站"><a href="#中国色配色网站" class="headerlink" title="中国色配色网站"></a><a href="http://zhongguose.com" target="_blank" rel="noopener">中国色配色网站</a></h5><h4 id="图片操作"><a href="#图片操作" class="headerlink" title="图片操作"></a>图片操作</h4><h5 id="AI图片放大"><a href="#AI图片放大" class="headerlink" title="AI图片放大"></a><a href="http://bigjpg.com/zh" target="_blank" rel="noopener">AI图片放大</a></h5><p>   通过Ai技术让图片尽可能放大，目前最大支持16X，想要获得高分辨率就快去试试吧！</p>
<img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/aifd.jpg">

<h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><h5 id="拷贝兔"><a href="#拷贝兔" class="headerlink" title="拷贝兔"></a><a href="https://cp.anyknew.com" target="_blank" rel="noopener">拷贝兔</a></h5><p>   临时共享文件的网站，一次最大200M，可微信登陆，支持阅后即焚。</p>
<img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/cbt.jpg">

<h4 id="程序员面试题库"><a href="#程序员面试题库" class="headerlink" title="程序员面试题库"></a>程序员面试题库</h4><h5 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a><a href="https://leetcode-cn.com" target="_blank" rel="noopener">LeetCode</a></h5><p>   leetcode 提供海量面试资源<br>   ………今天好累，懒得放图了，就假装有图吧………..</p>
<h4 id="办公开发软件"><a href="#办公开发软件" class="headerlink" title="办公开发软件"></a>办公开发软件</h4><h5 id="我爱分享网"><a href="#我爱分享网" class="headerlink" title="我爱分享网"></a><a href="http://www.zhanshaoyi.com/rjxz.html" target="_blank" rel="noopener">我爱分享网</a></h5><h3 id="高清图片，视频素材"><a href="#高清图片，视频素材" class="headerlink" title="高清图片，视频素材"></a>高清图片，视频素材</h3><p>   做PPT必备啊啊啊啊啊。。</p>
<img src="http://pz8wb8fk9.bkt.clouddn.com/static/images/gqsc.jpg">


<h3 id="项目开源"><a href="#项目开源" class="headerlink" title="项目开源"></a>项目开源</h3><h5 id="github"><a href="#github" class="headerlink" title="github"></a><a href="https://www.github.com" target="_blank" rel="noopener">github</a></h5><h5 id="开源中国"><a href="#开源中国" class="headerlink" title="开源中国"></a><a href="https://www.oschina.net/" target="_blank" rel="noopener">开源中国</a></h5><h5 id="码云"><a href="#码云" class="headerlink" title="码云"></a><a href="https://gitee.com" target="_blank" rel="noopener">码云</a></h5><h3 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h3><h5 id="爱资料工具"><a href="#爱资料工具" class="headerlink" title="爱资料工具"></a><a href="https://www.toolnb.com/" target="_blank" rel="noopener">爱资料工具</a></h5><p>   爱资料在线工具，为开发运维提供全面的在线工具箱，目前已开发工具270款，包含开发工具、运维工具、常用工具、SEO站长工具等，是好用，方便的在线工具网站。</p>
<h5 id="菜鸟工具"><a href="#菜鸟工具" class="headerlink" title="菜鸟工具"></a><a href="https://c.runoob.com/" target="_blank" rel="noopener">菜鸟工具</a></h5><p>   支持各种代码在线编辑运行。</p>
<p>好了，目前就这么多，以后找到好用的网站再更新吧~嘿嘿嘿</p>
<p>10.18更新</p>
<h5 id="免费图标网站"><a href="#免费图标网站" class="headerlink" title="免费图标网站"></a><a href="https://www.flaticon.com" target="_blank" rel="noopener">免费图标网站</a></h5><h3 id="视频音乐解析"><a href="#视频音乐解析" class="headerlink" title="视频音乐解析"></a>视频音乐解析</h3><h5 id="视频鱼"><a href="#视频鱼" class="headerlink" title="视频鱼"></a><a href="http://www.shipinyu.com" target="_blank" rel="noopener">视频鱼</a></h5><p>可以解析出非常多种类型的视频，无广告，免费</p>
<h5 id="唧唧"><a href="#唧唧" class="headerlink" title="唧唧"></a><a href="https://www.jijidown.com" target="_blank" rel="noopener">唧唧</a></h5><p>一个专门用来解析b站视频的网站</p>
]]></content>
      <categories>
        <category>资源共享</category>
      </categories>
  </entry>
  <entry>
    <title>什么是进制？</title>
    <url>/2019/10/11/%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E5%88%B6%EF%BC%9F/</url>
    <content><![CDATA[<h4 id="为什么要学习进制？"><a href="#为什么要学习进制？" class="headerlink" title="为什么要学习进制？"></a>为什么要学习进制？</h4><p>计算机只认识0和1，如果我们想更好地学习计算机，就必须理解进制是什么，数字是什么。</p>
<a id="more"></a>

<h5 id="学习进制的障碍："><a href="#学习进制的障碍：" class="headerlink" title="学习进制的障碍："></a>学习进制的障碍：</h5><p>很多人学不好进制，原因是总以十进制去依托去考虑其他进制，<br>需要运算的时候也总是事先转换成十进制，这种学习方法是错误的。<br>每一种进制都是完美的，它们自身遵守四则运算。</p>
<hr>
<h5 id="什么是进制？"><a href="#什么是进制？" class="headerlink" title="什么是进制？"></a>什么是进制？</h5><ol>
<li>进制的定义：</li>
</ol>
<ul>
<li>八进制的定义：由八个符号组成，分别是0 1 2 3 4 5 6 7 逢八进一。</li>
<li>十进制的定义：由十个符号组成，分别是0 1 2 3 4 5 6 7 8 9 逢十进一。</li>
<li>N进制的定义：由N个符号组成，逢N进一。</li>
</ul>
<ol start="2">
<li>进制计数法<br>进制计数法是：用有限个符号代表所有的数值的一种计数方式。<br>比如十进制就用0，1，2，3，4，5，6，7，8，9 十个符号表示所有的数字。</li>
<li>进制的本质是查数：</li>
</ol>
<ul>
<li>一进制：古人结绳记事，<table>
<thead>
<tr>
<th align="center">所用符号</th>
<th align="center">所能表示的事物</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">表示一个猎物</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">表示两个猎物</td>
</tr>
<tr>
<td align="center">111</td>
<td align="center">表示三个猎物</td>
</tr>
<tr>
<td align="center">1111</td>
<td align="center">表示四个猎物</td>
</tr>
</tbody></table>
</li>
<li><em>这种计数方式的好处在于所用的符号少，只有一个，但致命的缺点就是每增加一个猎物，就必须打一个结，如果我打了10000个猎物，今天就写不完了，hhh这样非常不方便计数。*</em></li>
<li>三进制：0~4（0 1 2 3 ）<table>
<thead>
<tr>
<th align="center">所用符号</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">整个三进制系统中没有4，故向前进一位</td>
</tr>
</tbody></table>
</li>
</ul>
<ol start="4">
<li><p>你理解进制了吗？1+1=3对吗？<br>十进制的定义：由十个符号组成，分别是0 1 3 2 8 7 6 9 4 5逢十进一。<br>十进制的定义：由十个符号组成，分别是A S B L K 7 6 V 9 5逢十进一。<br>你没有看错，以上两种定义都是正确的，因为进制本身并没有规定符号的排列顺序，也没有规定是什么符号，仅仅规定了符号的个数。</p>
<hr>
<h4 id="进制的运算"><a href="#进制的运算" class="headerlink" title="进制的运算"></a>进制的运算</h4><blockquote>
<p>每种进制都是完美的,不必转换成十进制运算.</p>
</blockquote>
<ol>
<li>八进制的运算:</li>
</ol>
</li>
</ol>
<ul>
<li>运算的本质是查数,建立数字表:0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27……..</li>
<li>比如2+3=5 很显然在上表在3的位置向后移动2位就得到结果.4+5=11 同理,在5的位置向后查4个数,得到11.</li>
<li>如果要计算277+333, 276*54, 234/4呢, 总不能一个一个查数吧. 于是乎, 出现了万恶的口诀表:</li>
</ul>
<table>
<thead>
<tr>
<th align="center">*</th>
<th align="center">*</th>
<th align="center">*</th>
<th align="center">*</th>
<th align="center">*</th>
<th align="center">*</th>
<th align="center">*</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1*1=1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1*2=2</td>
<td align="center">2*2=4</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1*3=3</td>
<td align="center">2*3=6</td>
<td align="center">3*3=11</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1*4=4</td>
<td align="center">2*4=10</td>
<td align="center">3*4=14</td>
<td align="center">4*4=20</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1*5=5</td>
<td align="center">2*5=12</td>
<td align="center">3*5=17</td>
<td align="center">4*5=24</td>
<td align="center">5*5=31</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1*6=6</td>
<td align="center">2*6=14</td>
<td align="center">3*6=22</td>
<td align="center">4*6=30</td>
<td align="center">5*6=36</td>
<td align="center">6*6=44</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1*7=7</td>
<td align="center">2*7=16</td>
<td align="center">3*7=25</td>
<td align="center">4*7=34</td>
<td align="center">5*7=43</td>
<td align="center">6*7=52</td>
<td align="center">7*7=61</td>
</tr>
</tbody></table>
<p>   <strong>别问我为什么和你小学学的乘法表不一样,因为这是八进制的乘法表.and 通过向上面这样建表查数的方法,可以完成所有进制的计算.</strong></p>
<hr>
<h4 id="计算机为什么使用二进制？"><a href="#计算机为什么使用二进制？" class="headerlink" title="计算机为什么使用二进制？"></a>计算机为什么使用二进制？</h4><ul>
<li>计算机是要用电的，电路只有两种状态：1真（通电）0假（未通电）</li>
<li>计算机中的任何文件、接收的任何指令都是由0和1组成的</li>
<li><del>使用UltraEdit查看一个.exe程序。</del></li>
</ul>
<ol>
<li>二进制的简写形式：(十六进制可以看成二进制的简写形式)</li>
</ol>
<p>用二进制从0写到1111<br>0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111<br>这种二进制使用起来太麻烦，改成更简单一点的符号：<br>0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F<br>这就是十六进制了，中国古代的时候就已经使用十六进制。</p>
]]></content>
      <tags>
        <tag>汇编</tag>
        <tag>进制</tag>
      </tags>
  </entry>
</search>
